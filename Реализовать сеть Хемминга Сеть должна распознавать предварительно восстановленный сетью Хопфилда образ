//Основные этапы реализации сети Хэмминга:
//Входной слой — принимает предварительно восстановленный образ.
//Распределение весов — вычисляет похожесть входного образа на эталонные образы.
//Слой классификации — определяет наиболее похожий эталонный образ на основе расстояния Хэмминга.

import java.util.Arrays;

public class HammingNetwork {
    private double[][] weights; // Матрица весов для эталонных образов
    private int numPatterns;    // Количество эталонных образов
    private int patternSize;    // Размер каждого образа

    // Конструктор для инициализации сети Хэмминга
    public HammingNetwork(int numPatterns, int patternSize) {
        this.numPatterns = numPatterns;
        this.patternSize = patternSize;
        this.weights = new double[numPatterns][patternSize];
    }

    // Метод для обучения сети с использованием эталонных образов
    public void train(int[][] patterns) {
        for (int i = 0; i < numPatterns; i++) {
            for (int j = 0; j < patternSize; j++) {
                weights[i][j] = 2 * patterns[i][j] - 1; // Преобразование: {0, 1} -> {-1, 1}
            }
        }
    }

    // Метод для классификации входного образа
    public int classify(int[] inputPattern) {
        double[] activations = new double[numPatterns];
        
        // Вычисление активации для каждого эталонного образа
        for (int i = 0; i < numPatterns; i++) {
            activations[i] = 0;
            for (int j = 0; j < patternSize; j++) {
                activations[i] += weights[i][j] * inputPattern[j];
            }
        }
        
        // Поиск индекса эталонного образа с максимальной активацией
        return argMax(activations);
    }

    // Вспомогательный метод для нахождения индекса максимального значения в массиве
    private int argMax(double[] array) {
        int maxIndex = 0;
        for (int i = 1; i < array.length; i++) {
            if (array[i] > array[maxIndex]) {
                maxIndex = i;
            }
        }
        return maxIndex;
    }

    // Метод для тестирования сети Хэмминга
    public static void main(String[] args) {
        // Определение эталонных образов (например, цифры 0 и 1 в виде 10x10 пикселей)
        int[][] patterns = {
            { /* Цифра 0, представлена как массив из 100 элементов со значениями 0 и 1 */ },
            { /* Цифра 1, представлена как массив из 100 элементов со значениями 0 и 1 */ }
        };

        HammingNetwork hammingNetwork = new HammingNetwork(2, 100);
        hammingNetwork.train(patterns);

        // Пример восстановленного образа от сети Хопфилда
        int[] restoredPattern = { /* Восстановленный образ цифры 0 или 1 */ };

        // Классификация восстановленного образа сетью Хэмминга
        int result = hammingNetwork.classify(restoredPattern);
        System.out.println("Распознанный образ: " + result);
    }
}


//Объяснение кода
//Обучение сети: Метод train() обучает сеть Хэмминга, преобразовывая каждый элемент эталонных образов из {0, 1} в { -1, 1 }, чтобы улучшить точность работы.
//Классификация: Метод classify() принимает входной образ и вычисляет активации для каждого эталонного образа, возвращая индекс образа с максимальной активацией.
//Преобразование данных: Образы для обучения и входные данные должны быть подготовлены таким образом, чтобы они были закодированы в виде массива значений 0 и 1.
//Примечания
//Точность классификации: Сеть Хэмминга лучше всего работает в сочетании с сетью Хопфилда, которая восстанавливает образ перед классификацией.
//Обучение: Веса сети устанавливаются таким образом, чтобы минимизировать расстояние Хэмминга между входным образом и эталонными образами, что позволяет достигнуть высокой точности распознавания.
