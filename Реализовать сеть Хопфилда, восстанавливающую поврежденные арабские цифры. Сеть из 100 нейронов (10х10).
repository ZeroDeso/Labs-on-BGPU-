//Шаги реализации сети Хопфилда
//Инициализация сети: Построим сеть из 100 нейронов, которые могут принимать значения 1 или -1.
//Обучение: Используем обучающие паттерны (цифры), чтобы сеть запомнила эти образы.
//Восстановление: Используем обученные веса для восстановления поврежденного изображения.
import java.util.Arrays;

public class HopfieldNetwork {
    private int[][] weights; // Матрица весов
    private int size;        // Размер сети (количество нейронов)

    // Конструктор для инициализации сети Хопфилда
    public HopfieldNetwork(int size) {
        this.size = size;
        this.weights = new int[size][size];
    }

    // Метод обучения сети на основе обучающих паттернов
    public void train(int[] pattern) {
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                if (i != j) {
                    weights[i][j] += pattern[i] * pattern[j];
                }
            }
        }
    }

    // Метод для обновления состояния сети и восстановления поврежденного образа
    public int[] recall(int[] inputPattern) {
        int[] outputPattern = Arrays.copyOf(inputPattern, inputPattern.length);

        for (int i = 0; i < size; i++) {
            int sum = 0;
            for (int j = 0; j < size; j++) {
                sum += weights[i][j] * outputPattern[j];
            }
            outputPattern[i] = (sum >= 0) ? 1 : -1; // Пороговая функция активации
        }

        return outputPattern;
    }

    // Метод для тестирования сети Хопфилда
    public static void main(String[] args) {
        HopfieldNetwork network = new HopfieldNetwork(100);

        // Пример обучающих паттернов (представление цифр в виде 10x10 пикселей)
        int[] digit0 = { /* Цифра 0, представлена как массив из 100 элементов со значениями 1 и -1 */ };
        int[] digit1 = { /* Цифра 1, представлена как массив из 100 элементов со значениями 1 и -1 */ };

        // Обучение сети на цифрах 0 и 1
        network.train(digit0);
        network.train(digit1);

        // Пример поврежденного паттерна для восстановления
        int[] noisyDigit = { /* Поврежденная версия цифры 0 или 1 */ };
        int[] restoredDigit = network.recall(noisyDigit);

        System.out.println("Восстановленный паттерн:");
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < 10; j++) {
                System.out.print(restoredDigit[i * 10 + j] == 1 ? "1 " : "0 ");
            }
            System.out.println();
        }
    }
}

//Объяснение кода
//Обучение сети: Метод train() обновляет веса по правилу Хебба. Паттерны кодируются значениями 1 (черный пиксель) и -1 (белый пиксель).
//Восстановление поврежденного изображения: Метод recall() обновляет состояние нейронов в зависимости от текущего состояния сети и возвращает восстановленное изображение.
//Тестирование сети: В блоке main() сеть обучается нескольким цифрам, а затем пытается восстановить поврежденный образ.
//Подготовка данных
//Для успешного обучения сети Хопфилда необходимо представить каждую цифру в виде массива из 100 значений, где каждый пиксель представлен как 1 или -1. Например
//1 — черный пиксель.
//-1 — белый пиксель.
